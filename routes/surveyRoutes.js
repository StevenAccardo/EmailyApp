//CREATES A USER DESIGNED SURVEY AND SENDS OUT A BIG E-MAIL TO RECIPIENT LIST
const _ = require('lodash');
const Path = require('path-parser');
//url is a module that comes packaged up with Node.
//Helps us parse URI paths
const { URL } = require('url');
//Importing mongoose and then importing the model class through mongoose instead of requiring it in striaght from the models directory because often times testing libraries will throw errors when they see you have imported a model class more than once.
const mongoose = require('mongoose');
//Imports the custom request handler
const requireLogin = require('../middlewares/requireLogin');
const requireCredits = require('../middlewares/requireCredits');
//Imports file that packeges up survey to send off to sendgrid
const Mailer = require('../services/Mailer');
const surveyTemplate = require('../services/emailTemplates/surveyTemplate');

const Survey = mongoose.model('surveys');

module.exports = app => {
  //Hits route, confirms auth, pulls the user
  //Passport queries the DB for the user, and if found, attaches the user propety to the req object
  app.get('/api/surveys', requireLogin, async (req, res) => {
    //.select({ recipients: false}) tells mongoose to grab all of the survey data, except for the recipient list.
    const surveys = await Survey.find({ _user: req.user.id }).select({
      recipients: false
    });
    res.send(surveys);
  });

  //Added this as the route for when a recipient clicks yes or no in the user's e-mail
  //The link is in the surveyTemplate.js file
  app.get('/api/surveys/:surveyId/:choice', (req, res) => {
    res.send('Thanks for voting!');
  });

  //accepts the post requests from sendgrid that contain the client responses to the survey
  app.post('/api/surveys/webhooks', (req, res) => {
    const p = new Path('/api/surveys/:surveyId/:choice');

    _.chain(req.body)
      .map(({ email, url }) => {
        const match = p.test(new URL(url).pathname);
        if (match) {
          return { email, surveyId: match.surveyId, choice: match.choice };
        }
      })
      .compact()
      .uniqBy('email', 'surveyId')
      .each(({ surveyId, email, choice }) => {
        Survey.updateOne(
          {
            _id: surveyId,
            recipients: {
              $elemMatch: { email: email, responded: false }
            }
          },
          {
            $inc: { [choice]: 1 },
            $set: { 'recipients.$.responded': true },
            lastResponded: new Date()
          }
        ).exec();
      })
      .value();

    res.send({});
  });

  //Handles the POST request for a user creating a new survey that needs to be saved to the database.
  //When passing multiple middlewares in as args, make sure to pass them in in the order you want them called, from left to right and always before the request handler function.
  app.post('/api/surveys', requireLogin, requireCredits, async (req, res) => {
    //es6 destructuring
    //req.body because body-parser middleware has already parsed the body and made it available in json format.
    const { title, subject, body, recipients } = req.body;

    //Using lowercase for the const name to indicate that this is an instance of a Survey.
    const survey = new Survey({
      title, //es6 title === title: title
      subject,
      body,
      //Takes the commas seperated string of emails, runs the split method on it, which will split the string into an array, with each item in the array being an individual e-mail. It then maps over each item in the array and makes an array with each item being a new object with the key being the word e-mail and the value being the e-mail string. Es6 syntax lets us condense the code. Note that parentheses are placed around the new object so that the JS parser doesn't think that the curly braces are for starting a new function. The trim() method is used to remove any white space before or after the e-mails.
      recipients: recipients.split(',').map(email => ({ email: email.trim() })),
      //this is the id property that is automatically generated by mongoDB, not the googleID that we created.
      _user: req.user.id,
      //returns a date object which mongoDB can read.
      dateSent: Date.now()
    });
    //THIS IS WHERE E-MAIL IS SENT

    //Use a try and catch in case ther are any issues that happen for the async calls
    try {
      //creates new instance of mailer, passes it the instance of survey and the surveyTemplate, which itself is passed the survey isntance.
      //Code for mailer creation can be found in Mailer.js file
      const mailer = new Mailer(survey, surveyTemplate(survey));
      //Takes our mailer above, and sends it off to sendGrid
      await mailer.send();
      //saves the newly created survey
      await survey.save();
      //reduces the user's credits by 1 credit
      req.user.credits -= 1;
      //saves the new user data to the User model class with the updated credits information
      //then stores the newly updated user data in a const, so we can continue using the most up to date document
      const user = await req.user.save();

      //sends back the updated user model, so the front end can update the number of credits the user has
      res.send(user);

      //If something goes wrong, we will send back an err and status of 422
    } catch (err) {
      res.status(422).send(err);
    }
  });
};
